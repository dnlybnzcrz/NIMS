{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\User\\\\Desktop\\\\pbs-issp-nims-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"C:\\\\Users\\\\User\\\\Desktop\\\\pbs-issp-nims-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport React, { useMemo, useRef, useEffect, useState, useContext } from 'react';\nimport { useDndContext, getClientRect, useDroppable, useDraggable, closestCorners, getFirstCollision, getScrollableAncestors, KeyboardCode } from '@dnd-kit/core';\nimport { useUniqueId, useIsomorphicLayoutEffect, CSS, useCombinedRefs, isKeyboardEvent, subtract } from '@dnd-kit/utilities';\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */\nfunction arrayMove(array, from, to) {\n  var newArray = array.slice();\n  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\n\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */\nfunction arraySwap(array, from, to) {\n  var newArray = array.slice();\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n  return newArray;\n}\nfunction getSortedRects(items, rects) {\n  return items.reduce(function (accumulator, id, index) {\n    var rect = rects.get(id);\n    if (rect) {\n      accumulator[index] = rect;\n    }\n    return accumulator;\n  }, Array(items.length));\n}\nfunction isValidIndex(index) {\n  return index !== null && index >= 0;\n}\nfunction itemsEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction normalizeDisabled(disabled) {\n  if (typeof disabled === 'boolean') {\n    return {\n      draggable: disabled,\n      droppable: disabled\n    };\n  }\n  return disabled;\n}\n\n// To-do: We should be calculating scale transformation\nvar defaultScale = {\n  scaleX: 1,\n  scaleY: 1\n};\nvar horizontalListSortingStrategy = function horizontalListSortingStrategy(_ref) {\n  var _rects$activeIndex;\n  var rects = _ref.rects,\n    fallbackActiveRect = _ref.activeNodeRect,\n    activeIndex = _ref.activeIndex,\n    overIndex = _ref.overIndex,\n    index = _ref.index;\n  var activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n  if (!activeNodeRect) {\n    return null;\n  }\n  var itemGap = getItemGap(rects, index, activeIndex);\n  if (index === activeIndex) {\n    var newIndexRect = rects[overIndex];\n    if (!newIndexRect) {\n      return null;\n    }\n    return _objectSpread({\n      x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n      y: 0\n    }, defaultScale);\n  }\n  if (index > activeIndex && index <= overIndex) {\n    return _objectSpread({\n      x: -activeNodeRect.width - itemGap,\n      y: 0\n    }, defaultScale);\n  }\n  if (index < activeIndex && index >= overIndex) {\n    return _objectSpread({\n      x: activeNodeRect.width + itemGap,\n      y: 0\n    }, defaultScale);\n  }\n  return _objectSpread({\n    x: 0,\n    y: 0\n  }, defaultScale);\n};\nfunction getItemGap(rects, index, activeIndex) {\n  var currentRect = rects[index];\n  var previousRect = rects[index - 1];\n  var nextRect = rects[index + 1];\n  if (!currentRect || !previousRect && !nextRect) {\n    return 0;\n  }\n  if (activeIndex < index) {\n    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n  }\n  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\nvar rectSortingStrategy = function rectSortingStrategy(_ref) {\n  var rects = _ref.rects,\n    activeIndex = _ref.activeIndex,\n    overIndex = _ref.overIndex,\n    index = _ref.index;\n  var newRects = arrayMove(rects, overIndex, activeIndex);\n  var oldRect = rects[index];\n  var newRect = newRects[index];\n  if (!newRect || !oldRect) {\n    return null;\n  }\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\nvar rectSwappingStrategy = function rectSwappingStrategy(_ref) {\n  var activeIndex = _ref.activeIndex,\n    index = _ref.index,\n    rects = _ref.rects,\n    overIndex = _ref.overIndex;\n  var oldRect;\n  var newRect;\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n  if (!newRect || !oldRect) {\n    return null;\n  }\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\n// To-do: We should be calculating scale transformation\nvar defaultScale$1 = {\n  scaleX: 1,\n  scaleY: 1\n};\nvar verticalListSortingStrategy = function verticalListSortingStrategy(_ref) {\n  var _rects$activeIndex;\n  var activeIndex = _ref.activeIndex,\n    fallbackActiveRect = _ref.activeNodeRect,\n    index = _ref.index,\n    rects = _ref.rects,\n    overIndex = _ref.overIndex;\n  var activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n  if (!activeNodeRect) {\n    return null;\n  }\n  if (index === activeIndex) {\n    var overIndexRect = rects[overIndex];\n    if (!overIndexRect) {\n      return null;\n    }\n    return _objectSpread({\n      x: 0,\n      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top\n    }, defaultScale$1);\n  }\n  var itemGap = getItemGap$1(rects, index, activeIndex);\n  if (index > activeIndex && index <= overIndex) {\n    return _objectSpread({\n      x: 0,\n      y: -activeNodeRect.height - itemGap\n    }, defaultScale$1);\n  }\n  if (index < activeIndex && index >= overIndex) {\n    return _objectSpread({\n      x: 0,\n      y: activeNodeRect.height + itemGap\n    }, defaultScale$1);\n  }\n  return _objectSpread({\n    x: 0,\n    y: 0\n  }, defaultScale$1);\n};\nfunction getItemGap$1(clientRects, index, activeIndex) {\n  var currentRect = clientRects[index];\n  var previousRect = clientRects[index - 1];\n  var nextRect = clientRects[index + 1];\n  if (!currentRect) {\n    return 0;\n  }\n  if (activeIndex < index) {\n    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n  }\n  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\nvar ID_PREFIX = 'Sortable';\nvar Context = /*#__PURE__*/React.createContext({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  disabled: {\n    draggable: false,\n    droppable: false\n  }\n});\nfunction SortableContext(_ref) {\n  var children = _ref.children,\n    id = _ref.id,\n    userDefinedItems = _ref.items,\n    _ref$strategy = _ref.strategy,\n    strategy = _ref$strategy === void 0 ? rectSortingStrategy : _ref$strategy,\n    _ref$disabled = _ref.disabled,\n    disabledProp = _ref$disabled === void 0 ? false : _ref$disabled;\n  var _useDndContext = useDndContext(),\n    active = _useDndContext.active,\n    dragOverlay = _useDndContext.dragOverlay,\n    droppableRects = _useDndContext.droppableRects,\n    over = _useDndContext.over,\n    measureDroppableContainers = _useDndContext.measureDroppableContainers;\n  var containerId = useUniqueId(ID_PREFIX, id);\n  var useDragOverlay = Boolean(dragOverlay.rect !== null);\n  var items = useMemo(function () {\n    return userDefinedItems.map(function (item) {\n      return typeof item === 'object' && 'id' in item ? item.id : item;\n    });\n  }, [userDefinedItems]);\n  var isDragging = active != null;\n  var activeIndex = active ? items.indexOf(active.id) : -1;\n  var overIndex = over ? items.indexOf(over.id) : -1;\n  var previousItemsRef = useRef(items);\n  var itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n  var disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n  var disabled = normalizeDisabled(disabledProp);\n  useIsomorphicLayoutEffect(function () {\n    if (itemsHaveChanged && isDragging) {\n      measureDroppableContainers(items);\n    }\n  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);\n  useEffect(function () {\n    previousItemsRef.current = items;\n  }, [items]);\n  var contextValue = useMemo(function () {\n    return {\n      activeIndex: activeIndex,\n      containerId: containerId,\n      disabled: disabled,\n      disableTransforms: disableTransforms,\n      items: items,\n      overIndex: overIndex,\n      useDragOverlay: useDragOverlay,\n      sortedRects: getSortedRects(items, droppableRects),\n      strategy: strategy\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);\n  return React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\nvar defaultNewIndexGetter = function defaultNewIndexGetter(_ref) {\n  var id = _ref.id,\n    items = _ref.items,\n    activeIndex = _ref.activeIndex,\n    overIndex = _ref.overIndex;\n  return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nvar defaultAnimateLayoutChanges = function defaultAnimateLayoutChanges(_ref2) {\n  var containerId = _ref2.containerId,\n    isSorting = _ref2.isSorting,\n    wasDragging = _ref2.wasDragging,\n    index = _ref2.index,\n    items = _ref2.items,\n    newIndex = _ref2.newIndex,\n    previousItems = _ref2.previousItems,\n    previousContainerId = _ref2.previousContainerId,\n    transition = _ref2.transition;\n  if (!transition || !wasDragging) {\n    return false;\n  }\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n  if (isSorting) {\n    return true;\n  }\n  return newIndex !== index && containerId === previousContainerId;\n};\nvar defaultTransition = {\n  duration: 200,\n  easing: 'ease'\n};\nvar transitionProperty = 'transform';\nvar disabledTransition = /*#__PURE__*/CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear'\n});\nvar defaultAttributes = {\n  roleDescription: 'sortable'\n};\n\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */\n\nfunction useDerivedTransform(_ref) {\n  var disabled = _ref.disabled,\n    index = _ref.index,\n    node = _ref.node,\n    rect = _ref.rect;\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    derivedTransform = _useState2[0],\n    setDerivedtransform = _useState2[1];\n  var previousIndex = useRef(index);\n  useIsomorphicLayoutEffect(function () {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      var initial = rect.current;\n      if (initial) {\n        var current = getClientRect(node.current, {\n          ignoreTransform: true\n        });\n        var delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height\n        };\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n  useEffect(function () {\n    if (derivedTransform) {\n      setDerivedtransform(null);\n    }\n  }, [derivedTransform]);\n  return derivedTransform;\n}\nfunction useSortable(_ref) {\n  var _ref$animateLayoutCha = _ref.animateLayoutChanges,\n    animateLayoutChanges = _ref$animateLayoutCha === void 0 ? defaultAnimateLayoutChanges : _ref$animateLayoutCha,\n    userDefinedAttributes = _ref.attributes,\n    localDisabled = _ref.disabled,\n    customData = _ref.data,\n    _ref$getNewIndex = _ref.getNewIndex,\n    getNewIndex = _ref$getNewIndex === void 0 ? defaultNewIndexGetter : _ref$getNewIndex,\n    id = _ref.id,\n    localStrategy = _ref.strategy,\n    resizeObserverConfig = _ref.resizeObserverConfig,\n    _ref$transition = _ref.transition,\n    transition = _ref$transition === void 0 ? defaultTransition : _ref$transition;\n  var _useContext = useContext(Context),\n    items = _useContext.items,\n    containerId = _useContext.containerId,\n    activeIndex = _useContext.activeIndex,\n    globalDisabled = _useContext.disabled,\n    disableTransforms = _useContext.disableTransforms,\n    sortedRects = _useContext.sortedRects,\n    overIndex = _useContext.overIndex,\n    useDragOverlay = _useContext.useDragOverlay,\n    globalStrategy = _useContext.strategy;\n  var disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n  var index = items.indexOf(id);\n  var data = useMemo(function () {\n    return _objectSpread({\n      sortable: {\n        containerId: containerId,\n        index: index,\n        items: items\n      }\n    }, customData);\n  }, [containerId, customData, index, items]);\n  var itemsAfterCurrentSortable = useMemo(function () {\n    return items.slice(items.indexOf(id));\n  }, [items, id]);\n  var _useDroppable = useDroppable({\n      id: id,\n      data: data,\n      disabled: disabled.droppable,\n      resizeObserverConfig: _objectSpread({\n        updateMeasurementsFor: itemsAfterCurrentSortable\n      }, resizeObserverConfig)\n    }),\n    rect = _useDroppable.rect,\n    node = _useDroppable.node,\n    isOver = _useDroppable.isOver,\n    setDroppableNodeRef = _useDroppable.setNodeRef;\n  var _useDraggable = useDraggable({\n      id: id,\n      data: data,\n      attributes: _objectSpread({}, defaultAttributes, userDefinedAttributes),\n      disabled: disabled.draggable\n    }),\n    active = _useDraggable.active,\n    activatorEvent = _useDraggable.activatorEvent,\n    activeNodeRect = _useDraggable.activeNodeRect,\n    attributes = _useDraggable.attributes,\n    setDraggableNodeRef = _useDraggable.setNodeRef,\n    listeners = _useDraggable.listeners,\n    isDragging = _useDraggable.isDragging,\n    over = _useDraggable.over,\n    setActivatorNodeRef = _useDraggable.setActivatorNodeRef,\n    transform = _useDraggable.transform;\n  var setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  var isSorting = Boolean(active);\n  var displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n  var shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  var dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n  var strategy = localStrategy != null ? localStrategy : globalStrategy;\n  var finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n    rects: sortedRects,\n    activeNodeRect: activeNodeRect,\n    activeIndex: activeIndex,\n    overIndex: overIndex,\n    index: index\n  }) : null;\n  var newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n    id: id,\n    items: items,\n    activeIndex: activeIndex,\n    overIndex: overIndex\n  }) : index;\n  var activeId = active == null ? void 0 : active.id;\n  var previous = useRef({\n    activeId: activeId,\n    items: items,\n    newIndex: newIndex,\n    containerId: containerId\n  });\n  var itemsHaveChanged = items !== previous.current.items;\n  var shouldAnimateLayoutChanges = animateLayoutChanges({\n    active: active,\n    containerId: containerId,\n    isDragging: isDragging,\n    isSorting: isSorting,\n    id: id,\n    index: index,\n    items: items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition: transition,\n    wasDragging: previous.current.activeId != null\n  });\n  var derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index: index,\n    node: node,\n    rect: rect\n  });\n  useEffect(function () {\n    if (isSorting && previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n  }, [isSorting, newIndex, containerId, items]);\n  useEffect(function () {\n    if (activeId === previous.current.activeId) {\n      return;\n    }\n    if (activeId && !previous.current.activeId) {\n      previous.current.activeId = activeId;\n      return;\n    }\n    var timeoutId = setTimeout(function () {\n      previous.current.activeId = activeId;\n    }, 50);\n    return function () {\n      return clearTimeout(timeoutId);\n    };\n  }, [activeId]);\n  return {\n    active: active,\n    activeIndex: activeIndex,\n    attributes: attributes,\n    data: data,\n    rect: rect,\n    index: index,\n    newIndex: newIndex,\n    items: items,\n    isOver: isOver,\n    isSorting: isSorting,\n    isDragging: isDragging,\n    listeners: listeners,\n    node: node,\n    overIndex: overIndex,\n    over: over,\n    setNodeRef: setNodeRef,\n    setActivatorNodeRef: setActivatorNodeRef,\n    setDroppableNodeRef: setDroppableNodeRef,\n    setDraggableNodeRef: setDraggableNodeRef,\n    transform: derivedTransform != null ? derivedTransform : finalTransform,\n    transition: getTransition()\n  };\n  function getTransition() {\n    if (\n    // Temporarily disable transitions for a single frame to set up derived transforms\n    derivedTransform ||\n    // Or to prevent items jumping to back to their \"new\" position when items change\n    itemsHaveChanged && previous.current.newIndex === index) {\n      return disabledTransition;\n    }\n    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {\n      return undefined;\n    }\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString(_objectSpread({}, transition, {\n        property: transitionProperty\n      }));\n    }\n    return undefined;\n  }\n}\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n  var _localDisabled$dragga, _localDisabled$droppa;\n  if (typeof localDisabled === 'boolean') {\n    return {\n      draggable: localDisabled,\n      // Backwards compatibility\n      droppable: false\n    };\n  }\n  return {\n    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n  };\n}\nfunction hasSortableData(entry) {\n  if (!entry) {\n    return false;\n  }\n  var data = entry.data.current;\n  if (data && 'sortable' in data && typeof data.sortable === 'object' && 'containerId' in data.sortable && 'items' in data.sortable && 'index' in data.sortable) {\n    return true;\n  }\n  return false;\n}\nvar directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\nvar sortableKeyboardCoordinates = function sortableKeyboardCoordinates(event, _ref) {\n  var _ref$context = _ref.context,\n    active = _ref$context.active,\n    collisionRect = _ref$context.collisionRect,\n    droppableRects = _ref$context.droppableRects,\n    droppableContainers = _ref$context.droppableContainers,\n    over = _ref$context.over,\n    scrollableAncestors = _ref$context.scrollableAncestors;\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n    if (!active || !collisionRect) {\n      return;\n    }\n    var filteredContainers = [];\n    droppableContainers.getEnabled().forEach(function (entry) {\n      if (!entry || entry != null && entry.disabled) {\n        return;\n      }\n      var rect = droppableRects.get(entry.id);\n      if (!rect) {\n        return;\n      }\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top < rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (collisionRect.top > rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (collisionRect.left > rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (collisionRect.left < rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n      }\n    });\n    var collisions = closestCorners({\n      active: active,\n      collisionRect: collisionRect,\n      droppableRects: droppableRects,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null\n    });\n    var closestId = getFirstCollision(collisions, 'id');\n    if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n      closestId = collisions[1].id;\n    }\n    if (closestId != null) {\n      var activeDroppable = droppableContainers.get(active.id);\n      var newDroppable = droppableContainers.get(closestId);\n      var newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n      var newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n      if (newNode && newRect && activeDroppable && newDroppable) {\n        var newScrollAncestors = getScrollableAncestors(newNode);\n        var hasDifferentScrollAncestors = newScrollAncestors.some(function (element, index) {\n          return scrollableAncestors[index] !== element;\n        });\n        var hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n        var isAfterActive = isAfter(activeDroppable, newDroppable);\n        var offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n          x: 0,\n          y: 0\n        } : {\n          x: isAfterActive ? collisionRect.width - newRect.width : 0,\n          y: isAfterActive ? collisionRect.height - newRect.height : 0\n        };\n        var rectCoordinates = {\n          x: newRect.left,\n          y: newRect.top\n        };\n        var newCoordinates = offset.x && offset.y ? rectCoordinates : subtract(rectCoordinates, offset);\n        return newCoordinates;\n      }\n    }\n  }\n  return undefined;\n};\nfunction isSameContainer(a, b) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n  return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\nfunction isAfter(a, b) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n  if (!isSameContainer(a, b)) {\n    return false;\n  }\n  return a.data.current.sortable.index < b.data.current.sortable.index;\n}\nexport { SortableContext, arrayMove, arraySwap, defaultAnimateLayoutChanges, defaultNewIndexGetter, hasSortableData, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, sortableKeyboardCoordinates, useSortable, verticalListSortingStrategy };","map":null,"metadata":{},"sourceType":"module"}